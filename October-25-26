import warnings
warnings.filterwarnings("ignore")

import numpy as np
import pandas as pd
try:
	import statsmodels.api as sm
except Exception:
	sm = None
	warnings.warn("statsmodels is not installed; continuing without it")

from scipy import stats
from scipy.stats import ttest_1samp
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats.mstats import winsorize
from scipy.stats import boxcox
from sklearn.preprocessing import LabelEncoder, OneHotEncoder



arr = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])



data = [10,12,23,23,16,23,21,16]
pop_mean = np.mean(data)
t_stat, p_value = ttest_1samp(data, pop_mean)


t_stat, p_value = ttest_1samp(data, pop_mean)
print(f"T-statistic: {t_stat}, P-value: {p_value}")

data1 = [10,12,23,23,16,23,21,16]
data2 = [12,14,22,20,18,24,20,18]
t_stat, p_value = stats.ttest_ind(data1, data2)
print(f"T-statistic: {t_stat}, P-value: {p_value}")

if p_value < 0.05:
    print("Reject the null hypothesis: The means are significantly different.")
else:
    print("Fail to reject the null hypothesis: The means are not significantly different.")


print("=============Z-TEST======================")



sample_data = [5.1, 6.2, 7.3, 5.8, 6.5, 7.0, 6.1, 5.9]
population_mean = 6.0
pop_std = 1.0
sample_mean = np.mean(sample_data)
n = len(sample_data)


z_stat = (sample_mean - population_mean) / (pop_std / np.sqrt(n))
p_value = 2 * (1 - stats.norm.cdf(abs(z_stat)))

print(f"Z-statistic: {z_stat}, P-value: {p_value}")


print("=============CHI - SQUARE -TEST======================")

observed_data= [50, 30, 20]
expected_data = [40, 40, 20]
chi2_stat, p_value = stats.chisquare(observed_data, expected_data)
print(f"Chi-square statistic: {chi2_stat}, P-value: {p_value}")


print("=============VARIANCE-TEST======================")

group1 = [10, 12, 14, 16, 18]
group2 = [20, 22, 24, 26, 28]
f_stat, p_value = stats.levene(group1, group2)
print(f"F-statistic: {f_stat}, P-value: {p_value}")

var1 = np.var(group1, ddof=1)
var2 = np.var(group2, ddof=1)


f_stat, p_value = stats.levene(group1, group2)
print(f"F-statistic: {f_stat}, P-value: {p_value}")

f_stat = var1 / var2
dof1 = len(group1) - 1
dof2 = len(group2) - 1
p_value = 1 - stats.f.cdf(f_stat, dof1, dof2)
print(f"F-statistic: {f_stat}, P-value: {p_value}")

print("=============OCTOBER-26======================")

df = pd.read_csv('HousePrices.csv')
print(df)

print("=============INFO======================")
df.info()
print("============HEAD=======================")
print(df.head(10))
print("==============TAIL=====================")	
print(df.tail())
print("=============DESCRIPTION======================")
print(df.describe())
print("=============DATA TYPES======================")
print(df.dtypes)
print("=============COLUMNS======================")
print(df.columns)
print("=============SHAPE======================")
print(df.shape)
print("=============NULL VALUES======================")
print(df.isnull().sum())
print("=============LOC======================")
print(df.loc[10])
print("=============ILOC======================")
print(df.iloc[10])
print("=============IS NULL ANY======================")
print(df.isnull().any())
print("=============DATE======================")
df['date']= pd.to_datetime(df['date'])
print(df['date'])
print("=============DATA TRANSFORMATION======================")
df['price_log'] = np.log(df['price']).apply(lambda x: round(x, 2))
print(df[['price', 'price_log']].head())
print("==============IQR====================")
Q1 = df['price'].quantile(0.25)
Q3 = df['price'].quantile(0.75)
plt.boxplot(df['price'])
#plt.show()
lower_bound = Q1 - 1.5 * (Q3 - Q1)
upper_bound = Q3 + 1.5 * (Q3 - Q1)
outliers = df[(df['price'] < lower_bound) | (df['price'] > upper_bound)]
print("Outliers based on IQR method:", outliers)
df['price_winso'] = df['price'].apply(lambda x: upper_bound if x > upper_bound else (lower_bound if x < lower_bound else x))
print(df[['price', 'price_winso']].head())
print("=============WINZORIZE======================")
df['price_winso2'] = winsorize(df['price'], limits=[0.05, 0.05])
print(df[['price', 'price_winso2']].head())
print("=============SEABORN PLOT======================")
sns.barplot(x='bedrooms', y='price', data=df)
#plt.show()
print("=============HISTOGRAM======================")
sns.histplot(df['price'])
#plt.show()
print("=============SCATTER PLOT======================")
sns.scatterplot(x='sqft_living', y='price', data=df, color='purple')
#plt.show()
print("=============HEATMAP======================")
num_df = df.select_dtypes(include=['float', 'int'])
corr_matrix = num_df.corr()
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm')	
#plt.show()
print("=============DATAFRAME======================")
dfr1 = pd.DataFrame({
	'A': [1, 2, 3],
	'B': ['a', 'b', 'c']})

dfr2 = pd.DataFrame({
	'A': [4, 5, 6],
	'B': ['d', 'e', 'f']})

dfr3 = pd.concat([dfr1, dfr2], ignore_index=True)
print(dfr3)
print("=============MERGE======================")
df_left = pd.DataFrame({
	'key': ['K0', 'K1', 'K2'],
	'A': ['A0', 'A1', 'A2']})
df_right = pd.DataFrame({
	'key': ['K0', 'K1', 'K2'],
	'B': ['B0', 'B1', 'B2']})
df_merged = pd.merge(df_left, df_right, on='key')	
print(df_merged)
print("=============FEATURE ENGINEERING======================")
df['TotalRooms'] = df['bedrooms'] + df['bathrooms']
print(df[['bedrooms', 'bathrooms', 'TotalRooms']].head())
print("=============SQUARE-ROOT======================")
df['sqft_living_sqrt'] = np.sqrt(df['sqft_living'])
print(df[['sqft_living', 'sqft_living_sqrt']].head())
print("=============BOX-COX======================")
df['price_boxcox'], fitted_lambda = boxcox(df['price'])
print(df[['price', 'price_boxcox']].head())
print("=============SCALERS(TRASFORMATIONS)======================")
from sklearn.preprocessing import MinMaxScaler, StandardScaler, RobustScaler
scaler = MinMaxScaler()
df['price_minmax'] = scaler.fit_transform(df[['price']])
print(df[['price', 'price_minmax']].head())
scaler = StandardScaler()
df['price_standard'] = scaler.fit_transform(df[['price']])
print(df[['price', 'price_standard']].head())
le = LabelEncoder()
encode = le.fit_transform(df['city'])
df['city_encoded'] = encode
print(df[['city', 'city_encoded']].head())
ohe = OneHotEncoder()
city_ohe = ohe.fit_transform(df[['city']])
print(city_ohe)